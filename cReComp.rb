#!/bin/ruby

# NAME
#         "cReComp.rb"
# DESCRIPTION
#         This is a code generator for Xillinux
# VERSION
#         2.0 24, Nov, 2015
# 
# (c) Kazushi Yamashina

# sub function
module Judge
# Judge yed or no
	def yes_no(flag)
		flag = STDIN.gets.chomp
		while flag != "y" && flag != "n"
			print "error! type \"y\" or \"n\" \n"
			flag = STDIN.gets.chomp
		end
		return flag
	end

	# Integer() int or string. if "str" is int  Integer() returns true
	def integer_string?(str)
	  Integer(str)
	  true
	rescue ArgumentError
	  false
	end

	# Integer() int or string. if "str" is int  Integer() returns true
	def float_string?(str)
	  Float(str)
	  true
	rescue ArgumentError
	  false
	end

	module_function :yes_no
	module_function :integer_string?
	module_function :float_string?
end

module Adv # output advertisment
	def out(str)
		print"\n"
		print "********************************\n"
		print "  #{str} \n"
		print "********************************\n"
	end
	module_function :out
end

# main block
Adv.out("Type your module name")
module_name = STDIN.gets.chomp

fo = open("devel/#{module_name}.v" , "w")

# select use of FIFO 8bit and 32bit
Adv.out("Do you use 32bit FIFO? [y/n]")
ans_32 = ""
ans_32 = Judge.yes_no(ans_32)

Adv.out("Do you use 8bit FIFO? [y/n]")
ans_8 = ""
ans_8 =  Judge.yes_no(ans_32)

# puts clk
fo.puts("`timescale 1ns / 1ps\n\n\n")
fo.puts("//this code was generated by cReComp\n")
fo.puts("module #{module_name}(")
fo.puts ("\ninput [0:0] clk,\n\n")

if ans_32 == "y" then
	fi = open("lib/lib32")
	fo.write(fi.read)
	fi.close
	if ans_8 == "y" then fo.puts(",\n\n") end
end
if ans_8 == "y" then
	fi = open("lib/lib8")
	fo.write(fi.read)
	fi.close
	puts "\n\n"
end

# make additonal ports
Adv.out("Do you make other ports? [y/n]")
ans_o = ""
ans_o = Judge.yes_no(ans_o)

ix = 0

port_stack = Array.new(100)
port_stack_max = 0
if ans_o == "y" then
	if ans_32 == "y" || ans_8 == "y" then
		fo.puts(",\n")
	elsif ans_32 == "n" && ans_8 == "n" then
		fo.puts("input [0:0] rst,\n")
	end
	l = ""
	while true
		print  "\nType [\"i\"/\"o\"/\"io\"],[bus width],[port name]\n"
		l = STDIN.gets.chomp

		print "\n"

		port = l.split(",")
		
		if Judge.integer_string?(port[1].to_s) == false && port[0] != "e"
			print "error ports declaration\n"
			next
		elsif port[2] == nil
			print "please define port name\n"
			next
		end

		case port[0]
		when "i" then
			port_io = "input"
		when "o" then
			port_io = "output"
		when "io"
			port_io = "inout"
		else
			if port[0] != "e" then
				print "error ports declaration\n"
				next
			end
		end

		port_stack[ix] = "#{port_io} [#{port[1].to_i-1}:0] #{port[2]}"
		fo.printf("#{port_stack[ix].to_s}")
		ix = ix + 1
		port_stack_max = ix
		print "If you finished, please type \"e\"\n"
		print "If you continue, please type Enter\n"
		l = STDIN.gets.chomp
		if l == "e" then
			fo.puts("\n")
			break
		else
			fo.puts(",\n")
		end
	end
end
fo.puts ");\n\n"

# generate instance for top module
fo.puts "// //copy this instance to top module"
fo.puts "//#{module_name} #{module_name}\n"
fo.puts "//(\n"
fo.puts "//.clk(bus_clk),\n"

if ans_32 == "y" then
	fi = open("lib/lib32inst")
	fo.write(fi.read)
	if ans_8 == "y" then fo.puts(",\n\n") end
end

if ans_8 == "y" then
	fi = open("lib/lib8inst")
	fo.write(fi.read)
	puts "\n\n"
end

if ans_o == "y" then
	if ans_32 == "y" || ans_8 == "y" then
		fo.puts("")
	else
		fo.puts("// .rst(rst),\n")
	end
	ix = 0
	while ix < port_stack_max
		inst = port_stack[ix].to_s.split(" ")
		fo.print "// .#{inst[2]}(#{inst[2]})"
		ix = ix + 1
		if ix < port_stack_max then fo.puts(",\n") end
	end
end
fo.puts "\n// );\n\n\n"

# generate parameter for FIFO state
if ans_32 == "y" then
	fi = open("lib/parameter_32")
	fo.write(fi.read)
end
if ans_8 == "y" then
	fi = open("lib/parameter_8")
	fo.write(fi.read)
end

# generate register for 32bit FIFO
if ans_32 == "y" then
	Adv.out("Do you make always block\nfor control 32bit FIFO? [y/n]")
	ans_32_alw = ""
	ans_32_alw = Judge.yes_no(ans_32_alw)

	if ans_32_alw == "y" then
		fo.puts "//for 32bit FIFO;"
		fo.puts "reg data_rcv_32;"
		fo.puts "reg data_snd_32;"
		fo.puts "\n"
	end
end

reg2fifo_stack_32_r = Array.new(100)
bit_witdh_32_r = Array.new(100)
reg2fifo_stack_32_s = Array.new(100)
bit_witdh_32_s = Array.new(100)
reg2fifo_32_max_r = 0
reg2fifo_32_max_s = 0

if ans_32_alw == "y" then
	ix = 0
	cur = 0
	Adv.out("You will set register to receive\n from the 32bit FIFO\n")
	l = ""
	while true
		print "Please type arbitrary bit width and register name\n"
		print "[bit width],[register name],[w(wire)/r(register)] default setting is \"reg\"\n"
		print "If you finished, please type \"e\"\n\n"
		l = STDIN.gets.chomp
		
		if l == "e" then break end
		print "\n"
		
		reg2fifo = l.split(",")

		# error check
		if Judge.integer_string?(reg2fifo[0].to_s) == false && reg2fifo[0] != "e"
			print "error ports declaration\n\n"
			next
		elsif reg2fifo[1] == nil
			print "please define name\n"
			next
		end

		cur = cur + reg2fifo[0].to_i

		if cur > 32 then
			print "error! Upper limit of 32bit FIFO was exceeded\n"
			cur = cur - reg2fifo[0].to_i
			next	
		elsif 
			bit_witdh_32_r[ix] = reg2fifo[0]
			reg2fifo_stack_32_r[ix] = reg2fifo[1]
			if reg2fifo[2] == "r"
				fo.puts "reg [#{reg2fifo[0].to_i-1}:0] #{reg2fifo[1]};\n"
			elsif reg2fifo[2] == "w"
				fo.puts "wire [#{reg2fifo[0].to_i-1}:0] #{reg2fifo[1]};\n"
			else
				fo.puts "reg [#{reg2fifo[0].to_i-1}:0] #{reg2fifo[1]};\n"
			end
		end
		ix = ix + 1
		reg2fifo_32_max_r = ix
		if cur == 32 then break end
	end
	ix = 0
	cur = 0
	Adv.out("You will assign wire to send\n to the 32bit FIFO\n")
	while true
		print "Please type arbitrary bit width and wire name\n"
		print "[bit width],[wire name],[w(wire)/r(register)] default setting is \"wire\"\n"
		print "If you finished, please type \"e\"\n\n"
		l = STDIN.gets.chomp

		if l == "e" then break end

		print "\n"
		
		reg2fifo = l.split(",")

		# error check
		if Judge.integer_string?(reg2fifo[0].to_s) == false && reg2fifo[0] != "e"
			print "error ports declaration\n\n"
			next
		elsif reg2fifo[1] == nil
			print "please define name\n"
			next
		end


		cur = cur +  reg2fifo[0].to_i

		if cur > 32 then
			print "error! Upper limit of 32bit FIFO was exceeded\n\n"
			cur = cur - reg2fifo[0].to_i
			next
		elsif 
			bit_witdh_32_s[ix] = reg2fifo[0]
			reg2fifo_stack_32_s[ix] = reg2fifo[1]
			if reg2fifo[2] == "r"
				fo.puts "reg [#{reg2fifo[0].to_i-1}:0] #{reg2fifo[1]};\n"
			elsif reg2fifo[2] == "w"
				fo.puts "wire [#{reg2fifo[0].to_i-1}:0] #{reg2fifo[1]};\n"
			else
				fo.puts "wire [#{reg2fifo[0].to_i-1}:0] #{reg2fifo[1]};\n"
			end
		end

		ix = ix + 1
		reg2fifo_32_max_s = ix
		if cur == 32 then break end

	end
end

# generate register for 8bit FIFO
if ans_8 == "y" then
	Adv.out("Do you make always block\nfor control 8bit FIFO? [y/n]")
	ans_8_alw = ""
	ans_8_alw = Judge.yes_no(ans_8_alw)

	if ans_8_alw == "y" then
		fo.puts "//for 8bit FIFO;"
		fo.puts "reg data_rcv_8;"
		fo.puts "reg data_snd_8;"
		fo.puts "\n"
	end
end

reg2fifo_stack_8_r = Array.new(100)
bit_witdh_8_r = Array.new(100)
reg2fifo_stack_8_s = Array.new(100)
bit_witdh_8_s = Array.new(100)
reg2fifo_8_max_r = 0
reg2fifo_8_max_s = 0

if ans_8_alw == "y" then
	ix = 0
	cur = 0
	Adv.out("You will set register to receive\n from the 8bit FIFO\n")
	l = ""
	while true
		print "Please type arbitrary bit width and register name\n"
		print "[bit width],[register name],[w(wire)/r(register)] default setting is \"reg\"\n"
		print "If you finished, please type \"e\"\n\n"
		l = STDIN.gets.chomp
		if l == "e" then break end
		
		print "\n"
		reg2fifo = l.split(",")

		# error check
		if Judge.integer_string?(reg2fifo[0].to_s) == false && reg2fifo[0] != "e"
			print "error ports declaration\n\n"
			next
		elsif reg2fifo[1] == nil
			print "please define name\n"
			next
		end

		cur = cur +  reg2fifo[0].to_i
		if cur > 8 then
			print "error! Upper limit of 8bit FIFO was exceeded\n"
			cur = cur - reg2fifo[0].to_i
			next
		elsif 
			bit_witdh_8_r[ix] = reg2fifo[0]
			reg2fifo_stack_8_r[ix] = reg2fifo[1]
			if reg2fifo[2] == "r"
				fo.puts "reg [#{reg2fifo[0].to_i-1}:0] #{reg2fifo[1]};\n"
			elsif reg2fifo[2] == "w"
				fo.puts "wire [#{reg2fifo[0].to_i-1}:0] #{reg2fifo[1]};\n"
			else
				fo.puts "reg [#{reg2fifo[0].to_i-1}:0] #{reg2fifo[1]};\n"
			end

		end
		ix = ix + 1
		reg2fifo_8_max_r = ix
		if cur == 8 then break end
	end
	ix = 0
	cur = 0
	Adv.out("You will set wire to send\n to the 8bit FIFO\n")
	while true
		print "Please type arbitrary bit width and wire name\n"
		print "[bit width],[wire name],[w(wire)/r(register)] default setting is \"wire\"\n"
		print "If you finished, please type \"e\"\n\n"
		l = STDIN.gets.chomp
		if l == "e" then break end
		print "\n"
		reg2fifo = l.split(",")

		# error check
		if Judge.integer_string?(reg2fifo[0].to_s) == false && reg2fifo[0] != "e"
			print "error ports declaration\n\n"
			next
		elsif reg2fifo[1] == nil
			print "please define name\n"
			next
		end

		cur = cur +  reg2fifo[0].to_i
		if cur > 8 then
			print "error! Upper limit of 8bit FIFO was exceeded\n\n"
			cur = cur - reg2fifo[0].to_i
			next
		elsif 
			bit_witdh_8_s[ix] = reg2fifo[0]
			reg2fifo_stack_8_s[ix] = reg2fifo[1]
			if reg2fifo[2] == "r"
				fo.puts "reg [#{reg2fifo[0].to_i-1}:0] #{reg2fifo[1]};\n"
			elsif reg2fifo[2] == "w"
				fo.puts "wire [#{reg2fifo[0].to_i-1}:0] #{reg2fifo[1]};\n"
			else
				fo.puts "wire [#{reg2fifo[0].to_i-1}:0] #{reg2fifo[1]};\n"
			end
		end
		ix = ix + 1
		reg2fifo_8_max_s = ix
		if cur == 8 then break end
	end
end

# generate sub module instance
Adv.out("Do you make instance sub module? [y/n]")
ans_sub = ""
ans_sub = Judge.yes_no(ans_sub)
if ans_sub == "y" then
	while true
		Adv.out("Type your sub module name\n if you finished please type \"e\"")
		sub_module_name = STDIN.gets.chomp
		if sub_module_name == "e"
			break
		end

		fo_s = open("devel/#{sub_module_name}.v" , "r")
		fo.puts "\n\n//instance for sub_module_name"
		l = ""
		while true
			l = fo_s.gets.chomp
			if l == "//this code was generated by cReComp"
				flag_ok = 1
				break
			elsif l == ");"
				break
			end
		end
		l = ""
		once = 0
		if flag_ok == 1
			fo.puts "#{sub_module_name} #{sub_module_name}\n\(\n"
			while l = fo_s.gets.chomp
				sub_port = l.split(" ")
				if sub_port[0] == ");"
					break
				elsif sub_port[0] == "input" || sub_port[0] == "output" || sub_port[0] == "inout"
					if once != 0
						fo.print ",\n"
					end
				end
				if sub_port[0] == "input" || sub_port[0] == "output" || sub_port[0] == "inout"
					fo.print ".#{sub_port[2].to_s.delete(",")}()"
					once = 1;
				end
			end
			fo.puts "\n);"
		end
		puts ""
	end
end

# generate always block for 32bit FIFO
i = 0
bitmin = 0
bitmax = 0
if ans_32_alw == "y" then
	fi = open("lib/lib_alw32")
	while true
		l = fi.gets.chomp
		if l == "/*user defined init*/"
			 fo.puts(l)
			break
		end
		fo.puts(l)
	end
	if reg2fifo_32_max_r > 0
		while i < reg2fifo_32_max_r
			fo.puts("\t\t#{reg2fifo_stack_32_r[i]} <= 0;\n")
			i = i + 1
		end
	end
	while true
		l = fi.gets.chomp
		if l == "/*user defined rcv*/"
			 fo.puts(l)
			break
		end
		fo.puts(l)
	end
	i = 0
	if reg2fifo_32_max_r > 0
		while i < reg2fifo_32_max_r
			bitmax = bitmin.to_i + bit_witdh_32_r[i].to_i - 1;
			fo.puts("\t\t#{reg2fifo_stack_32_r[i]} <= din_32[#{bitmax}:#{bitmin}];\n")
			i = i + 1
			bitmin = bitmax.to_i + 1
		end
	end
	while true
		l = fi.gets.chomp
		if l == "/*user assign*/"
			fo.puts(l)
			break
		end
		fo.puts(l)
	end
	i = 0
	bitmin = 0
	if reg2fifo_32_max_s > 0
		while i < reg2fifo_32_max_s
			bitmax = bitmin.to_i + bit_witdh_32_s[i].to_i - 1;
			fo.puts("assign dout_32[#{bitmax}:#{bitmin}] = #{reg2fifo_stack_32_s[i]};\n")
			i = i + 1
			bitmin = bitmax.to_i + 1
		end
	end
	while l = fi.gets
		fo.puts(l)
	end

end

# generate always block for 8bit FIFO
i = 0
bitmin = 0
bitmax = 0
if ans_8_alw == "y" then
	fi = open("lib/lib_alw8")
	while true
		l = fi.gets.chomp
		if l == "/*user defined init*/"
			 fo.puts(l)
			break
		end
		fo.puts(l)
	end
	if reg2fifo_8_max_r > 0
		while i < reg2fifo_8_max_r
			fo.puts("\t\t#{reg2fifo_stack_8_r[i]} <= 0;\n")
			i = i + 1
		end
	end
	while true
		l = fi.gets.chomp
		if l == "/*user defined rcv*/"
			 fo.puts(l)
			break
		end
		fo.puts(l)
	end
	i = 0
	if reg2fifo_8_max_r > 0
		while i < reg2fifo_8_max_r
			bitmax = bitmin.to_i + bit_witdh_8_r[i].to_i - 1;
			fo.puts("\t\t#{reg2fifo_stack_8_r[i]} <= din_8[#{bitmax}:#{bitmin}];\n")
			i = i + 1
			bitmin = bitmax.to_i + 1
		end
	end
	while true
		l = fi.gets.chomp
		if l == "/*user assign*/"
			fo.puts(l)
			break
		end
		fo.puts(l)
	end
	i = 0
	bitmin = 0
	if reg2fifo_8_max_s > 0
		while i < reg2fifo_8_max_s
			bitmax = bitmin.to_i + bit_witdh_8_s[i].to_i - 1;
			fo.puts("assign dout_8[#{bitmax}:#{bitmin}] = #{reg2fifo_stack_8_s[i]};\n")
			i = i + 1
			bitmin = bitmax.to_i + 1
		end
	end
	while l = fi.gets
		fo.puts(l)
	end

end


fo.puts "\n\nendmodule"

Adv.out("Show list of ports in this module\n ")
ix = 0
if port_stack_max > 0
	while ix < port_stack_max
		arr = port_stack[ix].split(" ")
		puts arr[2]
		ix = ix + 1
	end
end
ix = 0
if reg2fifo_32_max_r > 0
	while ix < reg2fifo_32_max_r
		puts reg2fifo_stack_32_r[ix]
		ix = ix + 1
	end
end
ix = 0
if reg2fifo_32_max_s > 0
	while ix < reg2fifo_32_max_s
		puts reg2fifo_stack_32_s[ix]
		ix = ix + 1
	end
end
ix = 0
if reg2fifo_8_max_r > 0
	while ix < reg2fifo_8_max_r
		puts reg2fifo_stack_8_r[ix]
		ix = ix + 1
	end
end
ix = 0
if reg2fifo_8_max_s > 0
	while ix < reg2fifo_8_max_s
		puts reg2fifo_stack_8_s[ix]
		ix = ix + 1
	end
end

puts "Generate #{module_name}.v"
