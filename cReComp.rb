#!/usr/bin/ruby
# NAME
#         "cReComp.rb"
# DESCRIPTION
#         This is a code generator for Reconfigurable Component
# 		  creator Reconfigurable HW componet
# VERSION
#         0.40  12 Dec 2015
# 
# (c) Kazushi Yamashina
require "./lib/check_option"
require "./lib/scrp_conf"
require "./lib/option_port"
require "./lib/fifo_32"
require "./lib/fifo_8"
require "./lib/sub_module"
module Read
	def lib(fo, str)
		fi = open(str)
		fo.write(fi.read)
	end
	module_function :lib
end

module Judge
# Judge yed or no
	# Integer() int or string. if "str" is int  Integer() returns true
	def integer_string?(str)
	  Integer(str)
	  true
	rescue ArgumentError
	  false
	end

	module_function :integer_string?
end

check = Check.new()
flag = ConfigFlag.new()

check.option(ARGV[0],ARGV[1])

dsl_file = ARGV[0]


# flag set
flag.set(dsl_file)

module_name = flag.get_module_name
fo = open("devel/#{module_name}.v" , "w")
module_type = flag.get_module_type

case module_type
	when "hs_slv"
		ans_hs_s = true
	when "hs_mst"
		ans_hs_m = true
	when "normal"
		ans_hs_s = false
		ans_hs_m = false
	else
		puts "Error! module_type"
		exit(0)
end

ans_32 = flag.get_use_fifo_32
ans_8 = flag.get_use_fifo_8
if flag.get_option_port
	ans_o = true
else
	ans_o = false
end
if ans_32  then
	ans_32_alw = flag.get_make_32_alw != false
end
if ans_8  then
	ans_8_alw = flag.get_make_8_alw != false
end
ans_sub = flag.get_sub_module

# define io port
fo.puts("`timescale 1ns / 1ps\n")
fo.puts("//this code was generated by cReComp\n")
fo.puts("module #{module_name}(")
fo.puts ("\ninput [0:0] clk,")
if ans_32 == false && ans_8 == false
	fo.puts ("input [0:0] rst,\n")
end
if ans_32
	Read.lib(fo,"lib/lib32")
	if ans_8 || ans_o then fo.puts(",\n") end
end
if ans_8 then
	Read.lib(fo,"lib/lib8")
	if ans_o then fo.puts(",\n") end
end

if ans_hs_s
	Read.lib(fo,"lib/hs_slv_port")
	if ans_o then fo.puts(",\n\n") end
end

# generate option port
obj = Option_port.new()
port_stack = []
if ans_o
	port_stack = obj.make(flag,fo)
end
fo.puts ");\n\n"

# generate instance for top module
fo.puts "// //copy this instance to top module"
fo.puts "//#{module_name} #{module_name}\n"
fo.puts "//(\n"
fo.puts "//.clk(bus_clk),\n"

if ans_32 then
	Read.lib(fo,"lib/lib32inst")
	if ans_8 || ans_o then fo.print(",\n//") end
end

if ans_8  then
	Read.lib(fo,"lib/lib8inst")
end

if ans_hs_s
	Read.lib(fo,"lib/hs_slv_inst")
end

if ans_o  then
	if ans_32 || ans_8 then
		fo.puts("")
	else
		fo.puts("// .rst(rst),\n")
	end
	ix = 0
	while ix < port_stack.count
		inst = port_stack[ix].to_s.split(" ")
		fo.print "// .#{inst[2]}(#{inst[2]})"
		ix = ix + 1
		if ix < port_stack.count then fo.puts(",\n") end
	end
end
fo.puts "\n//);\n"


# define parameter
if ans_hs_s
	Read.lib(fo,"lib/hs_slv_para")
end

if ans_32
	Read.lib(fo,"lib/fifo_32_para")
end
if ans_8
	Read.lib(fo,"lib/fifo_8_para")
end

# if ans_hs_m && ans_sub != nil
# 	i = 0
# 		while i < ans_sub.count	
# 			fi = open("lib/hs_mst_para")
# 			fo.puts "\n//for sub_module \"#{ans_sub[i]}\""
# 			while l = fi.gets
# 				fo.print "#{l.delete("\n")}_#{ans_sub[i]};\n"
# 			end
# 			i = i + 1
# 		end
# end

# generate register for 32bit FIFO
if ans_32_alw then
	fifo32 = FIFO32.new()
	fifo32.gen_reg(flag,fo)
end

# generate register for 8bit FIFO
if ans_8_alw then
	fifo8 = FIFO8.new()
	fifo8.gen_reg(flag,fo)
end

# generate sub module instance
if ans_sub  then
	sub = SubModule.new()
	sub.gen_inst(flag,fo) 
end

# generate always block for 32bit FIFO
if ans_32_alw
	fifo32.gen_alw(flag,fo)
end

# generate always block for 8bit FIFO
if ans_8_alw
	fifo8.gen_alw(flag,fo)
end

# generate always block of hand shake slave
if ans_hs_s
	Read.lib(fo,"lib/hs_slv_alw")
end

fo.puts "\n\nendmodule"

puts "Generate #{module_name}.v in ./devel"
