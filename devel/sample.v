`timescale 1ns / 1ps


//this code was generated by cReComp
module sample(

input [0:0] clk,

input [0:0] rst_32,
input [31:0] din_32,
input [0:0] wr_en_32,
input [0:0] rd_en_32,
output [31:0] dout_32,
output [0:0] full_32,
output [0:0] empty_32,

input [0:0] rst_8,
input [7:0] din_8,
input [0:0] wr_en_8,
input [0:0] rd_en_8,
output [7:0] dout_8,
output [0:0] full_8,
output [0:0] empty_8,

input [3:0] start
);

// //copy this instance to top module
//sample sample
//(
//.clk(bus_clk),
//    .rst_32(!user_w_write_32_open && !user_r_read_32_open),
//    .din_32(user_w_write_32_data),
//    .wr_en_32(user_w_write_32_wren),
//    .rd_en_32(user_r_read_32_rden),
//    .dout_32(user_r_read_32_data),
//    .full_32(user_w_write_32_full),
//    .empty_32(user_r_read_32_empty),

//     .rst_8(!user_w_write_8_open && !user_r_read_8_open),
//     .din_8(user_w_write_8_data),
//     .wr_en_8(user_w_write_8_wren),
//     .rd_en_8(user_r_read_8_rden),
//     .dout_8(user_r_read_8_data),
//     .full_8(user_w_write_8_full),
//     .empty_8(user_r_read_8_empty)
// .start(start)
//);


//for 32bit FIFO;
reg data_rcv_32;
reg data_snd_32;

reg [31:0] in_;
wire [7:0] out_0;
wire [7:0] out_1;
wire [7:0] out_2;
wire [7:0] out_3;


//for 8bit FIFO;
reg data_rcv_8;
reg data_snd_8;

reg [7:0] in_8;
wire [7:0] out_8_0;
wire [7:0] out_8_1;
wire [7:0] out_8_2;
wire [7:0] out_8_3;


//instance for adder
adder adder
(
.clk(),
.rst(),
.para0(),
.para1()
);

// control block for FIFO of 32bit

// processor => fpga
// If you have asserted "data_rcv_32", data will be incomming
// fpga => processor
// If you have asserted "data_snd_32", data will go out
assign full_32 = ~data_rcv_32;
assign empty_32 = ~data_snd_32;

// receive data from processor
always @(posedge clk) begin
	if (rst_32) begin
/*user defined init*/
		in_ <= 0;
	end
	else if (wr_en_32) begin
/*user defined rcv*/
		in_ <= din_32[31:0];
	end
	else begin
/*user defined */
	end
end

/*user assign*/
assign dout_32[7:0] = out_0;
assign dout_32[15:8] = out_1;
assign dout_32[23:16] = out_2;
assign dout_32[31:24] = out_3;

// state unit for FIFO
always @(posedge clk) begin
	if (rst_32) begin
		data_rcv_32 <= 0;
		data_snd_32 <= 0;
		state_32 <= INIT_32;
	end
	else if (state_32 == INIT_32)
		state_32 <= READ_32;
	else if (state_32 <= READ_32 && wr_en_32) begin
		data_rcv_32 <= 1;
		data_snd_32 <= 0;
		state_32 <= WRITE_32;
	end
	else if (state_32 <= WRITE_32 && rd_en_32) begin
		data_rcv_32 <= 0;
		data_snd_32 <= 1;
		state_32 <= INIT_32;
	end
end

// control block for FIFO of 8bit

// processor => fpga
// If you have asserted "data_rcv_8", data will be incomming
// fpga => processor
// If you have asserted "data_snd_8", data will go out
assign full_8 = ~data_rcv_8;
assign empty_8 = ~data_snd_8;

// receive data from processor
always @(posedge clk) begin
	if (rst_8) begin
/*user defined init*/
		in_8 <= 0;
	end
	else if (wr_en_8) begin
/*user defined rcv*/
		in_8 <= din_8[7:0];
	end
	else begin
/*user defined */
	end
end

/*user assign*/
assign dout_8[7:0] = out_8_0;
assign dout_8[15:8] = out_8_1;
assign dout_8[23:16] = out_8_2;
assign dout_8[31:24] = out_8_3;

// state unit for FIFO
always @(posedge clk) begin
	if (rst_8) begin
		data_rcv_8 <= 0;
		data_snd_8 <= 0;
		state_8 <= INIT_8;
	end
	else if (state_8 == INIT_8)
		state_8 <= READ_8;
	else if (state_8 <= READ_8 && wr_en_8) begin
		data_rcv_8 <= 1;
		data_snd_8 <= 0;
		state_8 <= WRITE_8;
	end
	else if (state_8 <= WRITE_8 && rd_en_8) begin
		data_rcv_8 <= 0;
		data_snd_8 <= 1;
		state_8 <= INIT_8;
	end
end


endmodule
